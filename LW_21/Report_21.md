# Отчёт по лабораторной работе №21
## по курсу "Фундаментальная информатика"

Студент группы М8О-108Б-23 Попов Александр Дмитриевич

Работа выполнена

Преподаватель: каф. 806 Севастьянов Виктор Сергеевич

1. **Тема**: Программирование на bash.
2. **Цель работы**: Написание bash скрипта.
3. **Задание:** Удаление файлов с указанным префиксом и с максимальными размерами, пока общий размер остающихся файлов не станет меньше заданного числа.
4. **Идея, метод, алгоритм решения задачи**: Расчитать размер каталога при помощи команды du; в цикле удалять файлы максимального размера с необходимым префиксом, используя команду find, пока размер директории не станет меньше границы или пока не закончатся файлы с заданным префиксом;
5. **Сценарий выполнения работы**: Запросить у пользователя границу суммарного размера файлов, префикс файлов, подлежащих удалению, и флаг включения режима предупреждения; проверить единицы измерения границы, выбрав последний её знак; в цикле удалять наибольшие файлы, сперва отсортировав вывод команды du, аргументом которой послужит find, а затем передав результат в rm при помощи повторного использования xargs; цикл будет идти, пока в каталоге есть файлы с искомым префиксом и общий размер файлов, не считая скриптов, превышает границу; подтверждение реализуется за счёт if;

| Входные данные тестового скрипта - входные данные рабочего скрипта | Выходные данные                        |
|--------------------------------------------------------------------|----------------------------------------|
| OR, 2M, 2; NU, 5M, 4; - 5M, NU                                      | OR1, OR2                              |
| PR, 8M, 5; OR, 2M, 2; - 2M, PR                                      | OR1, OR2                              |
| OR, 5M, 2; JF, 2M, 1; - 5M, OR                                      | JF1                                   |
| OR, 5M, 2; JF, 2M, 1; - 7M, OR                                      | JF1, OR1                              |
| OR, 25K, 4; JF, 15K, 4; - 109K, OR                                  | JF1, JF2, JF3, JF4, OR1               |
| OR, 2M, 4; JF, 1K, 1; - 2049K, OR                                   | JF1, OR1                              |
| OR, 2M, 4; JF, 1K, 1; - 0K, OR                                      | JF1, OR1, OR2, OR3, OR4               |

6. **Протокол**:
```
#!/bin/bash
cap=${1:-7M}
pref=${2:-"NU"}
checker=${3:-"check"}
dir_size=$(du -sm --apparent-size --exclude="*script" . | cut -f1)

units="${cap: -1}"
cap=${cap::-1}
if [ $units = "K" ]; then
	dir_size=$(du -s --apparent-size --exclude="*script" . | cut -f1)
fi

if [ "$checker" = "check" ]; then
	read -p "Tochno? Yes(y) / No(n): " answer
	if [ "$answer" = "y" ]; then
		while [ $dir_size -gt $cap -a $(find . -type f -name "$pref*" | wc -l) -gt 0 ]
		do
			find . -type f -name "$pref*" | xargs du | sort -r | head -n 1 | cut -f2 | xargs rm
			dir_size=$(du -sm --apparent-size --exclude="*script" . | cut -f1)
			if [ $units = "K" ]; then
				dir_size=$(du -s --apparent-size --exclude="*script" . | cut -f1)
			fi
		done
		echo "Gotovo!" 
	elif [ "$answer" = "n" ]; then
		echo "Ladno."
	else 
		echo "Incorrect input ti dal!"
	fi
else
	while [ $dir_size -gt $cap -a $(find . -type f -name "$pref*" | wc -l) -gt 0 ]; do
		find . -type f -name "$pref*" | xargs du | sort -r | head -n 1 | cut -f2 | xargs rm
		dir_size=$(du -sm --apparent-size --exclude="*script" . | cut -f1)
		if [ $units = "K" ]; then
			dir_size=$(du -s --apparent-size --exclude="*script" . | cut -f1)
		fi
	done
fi 
```
7. **Замечания автора** Для удобства тестирования был написан скрипт test_script и использованием команды truncate и цикла, который создаст нужное количество файлов заднного размера с указанным префиксом. Перевод параметров в другие системы измерения единиц информации возможны, но он повторяет уже реализованный. Так что он будет просто раздувать код, не меняя сути, но затрудняя чтение. Ещё если параметры скрипта пользователь не задаёт, то используются значения по умолчанию.
8. **Выводы**: Было освоено базовое программирование на bash, а также изучены новые команды, что в будущем поможет легче решать поставленные задачи. Кроме того, отладка на bash очень сложная, и это нужно учитывать при работе.
