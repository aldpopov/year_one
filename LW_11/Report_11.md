# Отчёт по лабораторной работе №15
## по курсу "Фундаментальная информатика"

Студент группы М8О-108Б-23 Попов Александр Дмитриевич

Работа выполнена

Преподаватель: каф. 806 Севастьянов Виктор Сергеевич

1. **Тема**: Решение задач на программирование с помощью языка Си. Конечные автоматы.
2. **Цель работы**: При помощи состояний решить задачу на языке Си.
3. **Задание:** Посчитать количество введённых отрицательных шестнадцатеричных чисел.
4. **Идея, метод, алгоритм решения задачи**: Выяснить критерий отрицательности в шестнадцатеричной системе счисления; при помощи состояний посчитать количество введённых отрицательных чисел, отсеяв лишние слова;
5. **Сценарий выполнения работы**: Для удобства создать новый тип state, отвечающий за текущее состояние; написать функцию is_sep для проверки символа на принадлежность к группе "разделителей"; написать состояние START для выбора действия в начале работы; написать состояние SEARCHING для поиска разделителя, после которого рано или поздно пойдёт слово; написать состояние CHECK_FIRST для проверки первой литеры на соответствие критерию отрицательности 16-ричной сс; Написать WORD_CHECK для проверки остального слова; ввести счётчик длины слова и результата;

| Входные данные                                          | Выходные данные                        |
|---------------------------------------------------------|----------------------------------------|
| &-1ffffffffffffffff  0f5,,f35 afefsdcvx                 | 0                                      |
|     fffffffffefefafea                                   | 1                                      |
| +FFhdfsj 0FEAAFEEFAB21370,,,  9ffffFABEABCDEF65 &-164   | 1                                      |

6. **Протокол**:
```
#include <stdio.h>
#include <ctype.h>

typedef enum {
    START_STATE,
    SEARCH_STATE,
    CHECK_FIRST,
    WORD_CHECK
}state;

int is_sep(int h){
    return (h == ' ') || (h == ',') || (h == '\t') || (h == '\n') || (h == EOF);
}

int main() {
    int ch = 0;
    int result = 0;
    int len_count = 0;
    state s = START_STATE;
    while(ch = getchar()) {
        switch(s) {
            case START_STATE: {
                if(is_sep(ch)) {
                    s = CHECK_FIRST;
                }
                else if(isxdigit(ch) && ch >= '8'){
                    len_count++;
                    s = WORD_CHECK;
                }
                else {
                    s = SEARCH_STATE;
                }
            }
            break;
            
            case SEARCH_STATE: {
                if(is_sep(ch)) {
                    s = CHECK_FIRST;
                    if(ch == EOF) {
                        goto end;
                    }
                }
            }
            break;
            
            case CHECK_FIRST: {
                if(isxdigit(ch) && ch >= '8') {
                    len_count++;
                    s = WORD_CHECK;
                }
                else if(is_sep(ch) == 0) {
                    s = SEARCH_STATE;
                }
                if(ch == EOF) {
                    goto end;
                }
            }
            break;
            
            case WORD_CHECK: {
                if(isxdigit(ch)) {
                    len_count++;
                }
                else if(is_sep(ch)) {
                    if(len_count == 16) {
                        result++;
                    }
                    len_count = 0;
                    s = CHECK_FIRST;
                    if(ch == EOF) {
                        goto end;
                    }
                }
                else {
                    len_count = 0;
                    s = SEARCH_STATE;
                }
            }
            break;
        }
    }
    end: {
        printf("\nКоличество отрицательных шестнадцатеричных чисел: %d", result);
        return 1;
    }
}
```
7. **Замечания автора** по существу работы: Чтобы число в шестнадцатеричной записи было отрицательным, достаточно, чтобы самый левый из его 16 бит был больше или равен 8. Строчные буквы также считаются частью шестнадцатеричного алфавита. Ещё лучше не забывать ставить break после каждого case, ведь иначе выполнение кейса пойдёт в любом случае. Функция isxdigit проверяет литеру на принадлежность алфавиту 16-ричной СС.
8. **Выводы**: Изучены конечные автоматы и состояния в языке Си. Освоено создание новых типов данных, и проведена работа с switch и case, встречаться с которыми раньше мне не доводилось.
